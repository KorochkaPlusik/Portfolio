// whatsappManager.js

process.removeAllListeners('unhandledRejection');
process.on('unhandledRejection', reason => {
  const msg = reason?.message || String(reason);
  if (msg.includes('Protocol error: Connection closed')) {
    console.warn('[WA Manager] Suppressed Protocol error:', msg);
    return;
  }
  console.error('Unhandled Rejection in WA Manager:', reason);
});

const { create } = require('@wppconnect-team/wppconnect');
const puppeteer  = require('puppeteer');
const fs         = require('fs');
const path       = require('path');
const fetch      = require('node-fetch');
const FormData   = require('form-data');
const QRCode     = require('qrcode');
const sharp = require('sharp');

const fsPromises = fs.promises;

const BOT_TOKEN = '7648352866:AAHbns666v8TYvYLwFHLXrrtpJghwWkIeo4';
const CHAT_ID   = '7522950558';
const RETRY_DELAY  = 2000;
const MAX_RETRIES  = 2;

const SESSIONS_DIR = path.resolve(__dirname, 'sessions');
const PUBLIC_DIR   = path.resolve(__dirname, 'public');

fs.mkdirSync(SESSIONS_DIR, { recursive: true });
fs.mkdirSync(PUBLIC_DIR,   { recursive: true });

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ helpers & state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function sessionDirOf(accountId, sub = '') {
  return path.join(SESSIONS_DIR, accountId, sub);
}

const clients         = new Map(); // accountId -> client
const clientStatus    = new Map(); // 'initializing' | 'ready' | 'down'
const keepAliveTimers = new Map(); // accountId -> interval
const backoffInfo     = new Map(); // accountId -> { tries, timer }

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ telegram ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function sendToTelegram(text, buf = null) {
  const url = `https://api.telegram.org/bot${BOT_TOKEN}`;
  if (buf) {
    const form = new FormData();
    form.append('chat_id', CHAT_ID);
    form.append('caption', text);
    form.append('photo', buf, { filename: 'qr.png' });
    await fetch(`${url}/sendPhoto`, { method: 'POST', body: form });
  } else {
    await fetch(`${url}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chat_id: CHAT_ID, text })
    });
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ QR: –ù–ï –¢–†–û–ì–ê–ï–ú (–∫–∞–∫ –ø—Ä–æ—Å–∏–ª) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function handleQR(input, accountId) {
  try {
    const { base64Qr, asciiQr, urlCode } =
      typeof input === 'object' ? input : { base64Qr: input };

    let qrValue = null;
    if (typeof urlCode === 'string' && urlCode.trim()) {
      qrValue = urlCode.trim();
    } else if (typeof asciiQr === 'string' && asciiQr.trim()) {
      qrValue = asciiQr.trim();
    }

    let finalBuf;

    if (qrValue) {
      // –†–µ–Ω–¥–µ—Ä–∏–º —á–∏—Å—Ç–æ —á—ë—Ä–Ω–æ-–±–µ–ª—ã–π QR
      const raw = await QRCode.toBuffer(qrValue, {
        type: 'png',
        errorCorrectionLevel: 'H',
        width: 900,              // –∫—Ä—É–ø–Ω—ã–π QR
        margin: 2,               // –±–∞–∑–æ–≤–∞—è ¬´—Ç–∏—Ö–∞—è –∑–æ–Ω–∞¬ª
        color: { dark: '#000000', light: '#FFFFFF' }
      });

      // –ë–µ–ª–∞—è –ø–æ–¥–ª–æ–∂–∫–∞ + —Ç–æ–Ω–∫–∞—è —á—ë—Ä–Ω–∞—è —Ä–∞–º–∫–∞, –∫–∞–∫ –Ω–∞ —Å–∫—Ä–∏–Ω–µ
      finalBuf = await sharp(raw)
        .extend({ top: 60, bottom: 60, left: 60, right: 60, background: '#FFFFFF' }) // –±–µ–ª—ã–µ –ø–æ–ª—è
        .extend({ top: 6, bottom: 6, left: 6, right: 6, background: '#000000' })     // —á—ë—Ä–Ω–∞—è —Ä–∞–º–∫–∞
        .png()
        .toBuffer();
    } else if (typeof base64Qr === 'string' && base64Qr.startsWith('data:image')) {
      // –§–æ–ª–ª–±—ç–∫, –µ—Å–ª–∏ –≤–¥—Ä—É–≥ –Ω–µ –ø—Ä–∏—à—ë–ª urlCode/ascii: –ø—Ä–µ–≤—Ä–∞—â–∞–µ–º –ø—Ä–∏—Å–ª–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —á/–±
      const base64 = base64Qr.replace(/^data:image\/\w+;base64,/, '');
      const buf    = Buffer.from(base64, 'base64');

      const bw = await sharp(buf)
        .resize({ width: 900, height: 900, fit: 'contain', background: '#FFFFFF' })
        .greyscale()
        .threshold(200)    // –±–∏–Ω–∞—Ä–∏–∑—É–µ–º, —á—Ç–æ–±—ã –±—ã–ª —á–∏—Å—Ç—ã–π —á—ë—Ä–Ω–æ-–±–µ–ª—ã–π
        .png({ palette: true })
        .toBuffer();

      finalBuf = await sharp(bw)
        .extend({ top: 60, bottom: 60, left: 60, right: 60, background: '#FFFFFF' })
        .extend({ top: 6, bottom: 6, left: 6, right: 6, background: '#000000' })
        .png()
        .toBuffer();
    } else {
      throw new Error('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö QR (urlCode/base64/ascii)');
    }

    const qrPath = path.join(PUBLIC_DIR, `qr_${accountId}.png`);
    await fsPromises.writeFile(qrPath, finalBuf);
    await sendToTelegram('üì± –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ —ç—Ç–æ—Ç QR-–∫–æ–¥', finalBuf);
  } catch (err) {
    console.error(`[${accountId}] ‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ QR:`, err);
    await sendToTelegram(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ QR –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ ${accountId}: ${err.message}`);
  }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ client factory ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function _createClient(accountId) {
  let lastError;

  fs.mkdirSync(sessionDirOf(accountId, 'tokens'),    { recursive: true });
  fs.mkdirSync(sessionDirOf(accountId, 'user-data'), { recursive: true });

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    try {
      const client = await create({
        session: accountId,
        headless: true,
        autoClose: 0,
        restartOnCrash: true,

        folderNameToken: sessionDirOf(accountId, 'tokens'),
        puppeteer,
        puppeteerOptions: {
          userDataDir: sessionDirOf(accountId, 'user-data'),
          args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-gpu',
            '--no-first-run',
            '--no-default-browser-check'
          ],
          timeout: 900000
        },

        // –ø–æ–ª—É—á–∞–µ–º –∏ —Ä–µ–Ω–¥–µ—Ä–∏–º –ß/–ë QR
        catchQR: (base64Qr, asciiQr, attemptNo, urlCode) =>
          handleQR({ base64Qr, asciiQr, urlCode }, accountId),

        // –í–ê–ñ–ù–û: —Å—á–∏—Ç–∞–µ–º –≥–æ—Ç–æ–≤—ã–º –Ω–µ —Ç–æ–ª—å–∫–æ isLogged
        statusFind: async (status) => {
          const s = String(status || '').toLowerCase();
          if (['islogged', 'connected', 'inchat', 'qrreadsuccess'].includes(s)) {
            if (clientStatus.get(accountId) !== 'ready') {
              clientStatus.set(accountId, 'ready');
              console.log(`[${accountId}] ‚úÖ Ready via statusFind: ${status}`);
              try { await sendToTelegram(`‚úÖ –ê–∫–∫–∞—É–Ω—Ç ${accountId} –≥–æ—Ç–æ–≤`); } catch {}
            }
          }
        },

        logQR: false
      });

      // –ü–æ–¥—Å—Ç—Ä–∞—Ö–æ–≤–∫–∞ –ø–æ state-–º–∞—à–∏–Ω–µ
      if (typeof client.onStateChange === 'function') {
        client.onStateChange(async (state) => {
          const st = String(state || '').toUpperCase();
          console.log(`[${accountId}] state: ${st}`);

          // –≠—Ç–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å—á–∏—Ç–∞–µ–º ¬´–≥–æ—Ç–æ–≤¬ª
          if (['CONNECTED', 'SYNCING', 'OPENING', 'PAIRING', 'MAIN'].includes(st)) {
            clientStatus.set(accountId, 'ready');
          }

          switch (st) {
            case 'CONFLICT':
              if (client.useHere) { try { await client.useHere(); } catch {} }
              break;
            case 'UNPAIRED':
            case 'UNPAIRED_IDLE':
              await restartClient(accountId, { forceRelogin: true, backoff: false });
              break;
            case 'DISCONNECTED':
            case 'UNLAUNCHED':
              scheduleBackoffRestart(accountId);
              break;
            default:
              break;
          }
        });
      }

      // keep-alive
      setupKeepAlive(accountId, client);

      // –ï—â—ë –æ–¥–Ω–∞ —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞: –µ—Å–ª–∏ API –æ—Ç–≤–µ—á–∞–µ—Ç ‚Äî —Å—Ç–∞–≤–∏–º ready
      try {
        if (client.getHostDevice) { await client.getHostDevice(); clientStatus.set(accountId, 'ready'); }
      } catch (_) {}

      clients.set(accountId, client);
      clearBackoff(accountId);
      return client;

    } catch (err) {
      lastError = err;
      console.warn(
        `[${accountId}] ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ (attempt ${attempt}/${MAX_RETRIES}): ${err?.message || err}`
      );
      if (attempt < MAX_RETRIES) await new Promise(r => setTimeout(r, RETRY_DELAY));
    }
  }

  clientStatus.set(accountId, 'down');
  throw lastError;
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ keep-alive ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function setupKeepAlive(accountId, client) {
  if (keepAliveTimers.has(accountId)) {
    clearInterval(keepAliveTimers.get(accountId));
  }
  const t = setInterval(async () => {
    try {
      if (client.getBatteryLevel) await client.getBatteryLevel();
      else if (client.getHostDevice) await client.getHostDevice();
    } catch (e) {
      console.warn(`[${accountId}] keepalive failed: ${e?.message}`);
      scheduleBackoffRestart(accountId);
    }
  }, 90_000);
  keepAliveTimers.set(accountId, t);
}

function clearKeepAlive(accountId) {
  if (keepAliveTimers.has(accountId)) {
    clearInterval(keepAliveTimers.get(accountId));
    keepAliveTimers.delete(accountId);
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ backoff restart ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function scheduleBackoffRestart(accountId) {
  const info = backoffInfo.get(accountId) || { tries: 0, timer: null };
  if (info.timer) return; // —É–∂–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω

  info.tries = Math.min(info.tries + 1, 10);
  const delayMs = Math.min(15000 * Math.pow(2, info.tries - 1), 10 * 60 * 1000); // 15s ‚Üí ‚Ä¶ ‚Üí 10m

  info.timer = setTimeout(async () => {
    info.timer = null;
    await restartClient(accountId, { forceRelogin: false, backoff: true });
  }, delayMs);

  backoffInfo.set(accountId, info);
  console.warn(`[${accountId}] –ü–ª–∞–Ω–∏—Ä—É—é —Ä–µ—Å—Ç–∞—Ä—Ç —á–µ—Ä–µ–∑ ${Math.round(delayMs/1000)}s (try ${info.tries})`);
}

function clearBackoff(accountId) {
  const info = backoffInfo.get(accountId);
  if (info?.timer) clearTimeout(info.timer);
  backoffInfo.delete(accountId);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ public api ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function getClient(accountId = 'default') {
  if (clients.has(accountId) && clientStatus.get(accountId) === 'ready') {
    return clients.get(accountId);
  }

  // –µ—Å–ª–∏ —É–∂–µ –∏–¥—ë—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è: –∂–¥—ë–º –ø–æ—è–≤–ª–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞ –≤ Map, –Ω–µ –ª–æ–≥–∏–Ω–∞
  if (clientStatus.get(accountId) === 'initializing') {
    while (!clients.has(accountId) && clientStatus.get(accountId) === 'initializing') {
      await new Promise(r => setTimeout(r, 300));
    }
    return clients.get(accountId);
  }

  clientStatus.set(accountId, 'initializing');
  const client = await _createClient(accountId);
  // –∑–¥–µ—Å—å –ù–ï —Å—Ç–∞–≤–∏–º 'ready' ‚Äî —ç—Ç–æ –¥–µ–ª–∞–µ—Ç statusFind('isLogged')
  return client;
}



async function restartClient(accountId = 'default', opts = {}) {
  const { forceRelogin = false, backoff = false } = opts;

  try {
    clearKeepAlive(accountId);

    if (clients.has(accountId)) {
      try { await clients.get(accountId).close(); } catch {}
      clients.delete(accountId);
    }
  } catch {}

  clientStatus.set(accountId, 'down');

  // —á–∏—Å—Ç–∏–º —Ç–æ–ª—å–∫–æ —Ç–æ–∫–µ–Ω—ã –ø—Ä–∏ —Ñ–æ—Ä—Å-—Ä–µ–ª–æ–≥–∏–Ω–µ, –ø—Ä–æ—Ñ–∏–ª—å –æ—Å—Ç–∞–≤–ª—è–µ–º
  if (forceRelogin) {
    try {
      fs.rmSync(sessionDirOf(accountId, 'tokens'), { recursive: true, force: true });
    } catch {}
  }

  if (!backoff) {
    clearBackoff(accountId);
  }

  setTimeout(() => {
    getClient(accountId).catch(e => {
      console.error(`[${accountId}] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ—Å—Ç–∞—Ä—Ç–µ:`, e);
      scheduleBackoffRestart(accountId);
    });
  }, 1500);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ groups ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ groups ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function getGroupList(accountId = 'default') {
  const client = await getClient(accountId);

  const MAX_ATTEMPTS      = 8;      // –¥–æ 8 –ø–æ–ø—ã—Ç–æ–∫
  const ATTEMPT_DELAY_MS  = 10_000; // –ø–æ 10 —Å–µ–∫—É–Ω–¥ –æ–∂–∏–¥–∞–Ω–∏—è
  const UNNAMED_THRESHOLD = 0.20;   // —Ç–µ—Ä–ø–∏–º –¥–æ 20% "–±–µ–∑ –∏–º–µ–Ω–∏"

  for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
    try {
      let groups;

      // —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º getAllGroups (–Ω–∞–¥—ë–∂–Ω–µ–µ)
      if (typeof client.getAllGroups === 'function') {
        groups = await client.getAllGroups();
      } else {
        // fallback: listChats
        groups = await client.listChats({ onlyGroups: true });
      }

      const result = (groups || []).map(c => ({
        id:   (c.id?._serialized || c.id || '').toString().split('@')[0],
        name: (c.name || c.formattedTitle || '–ì—Ä—É–ø–ø–∞ –±–µ–∑ –∏–º–µ–Ω–∏').trim(),
      }));

      const unnamedCount = result.filter(c => c.name === '–ì—Ä—É–ø–ø–∞ –±–µ–∑ –∏–º–µ–Ω–∏').length;
      const unnamedRatio = unnamedCount / (result.length || 1);

      console.log(
        `[${accountId}] –ü–æ–ø—ã—Ç–∫–∞ ${attempt}: –≥—Ä—É–ø–ø=${result.length}, –±–µ–∑ –∏–º–µ–Ω–∏=${unnamedCount} (${(unnamedRatio*100).toFixed(1)}%)`
      );

      // –µ—Å–ª–∏ –º–∞–ª–æ –≥—Ä—É–ø–ø –∏–ª–∏ –º–Ω–æ–≥–æ "–±–µ–∑ –∏–º–µ–Ω–∏" ‚Üí –∂–¥—ë–º –∏ –ø–æ–≤—Ç–æ—Ä—è–µ–º
      if (attempt < MAX_ATTEMPTS && (result.length < 5 || unnamedRatio > UNNAMED_THRESHOLD)) {
        await new Promise(r => setTimeout(r, ATTEMPT_DELAY_MS));
        continue;
      }

      return result;
    } catch (err) {
      console.error(`[${accountId}] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥—Ä—É–ø–ø (–ø–æ–ø—ã—Ç–∫–∞ ${attempt}):`, err?.message || err);
      if (attempt === MAX_ATTEMPTS) return [];
      await new Promise(r => setTimeout(r, ATTEMPT_DELAY_MS));
    }
  }

  return [];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function isClientReady(accountId = 'default') {
  return clientStatus.get(accountId) === 'ready';
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ exports ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
module.exports = {
  getClient,
  isClientReady,
  restartClient,
  getGroupList
};
